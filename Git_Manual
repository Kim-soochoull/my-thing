My GIT_MANUAL -*- mode: org -*-
#+STARTUP: showall
* 1장 시작하기
  
** 1.1 버전관리
   
   버전 관리 시스템은 파일 변화를 시간에 따라 기록했다가 나중에 특정 시점의
   버전을 다시 꺼내올 수 있는 시스템이다.

   프로그램 소스코드나, 그래픽 디자이너, 웹 디자이너도 *VCS* (Version Control
   System: 버전 관리 시스템)를 사용할 수 있다. VCS를 사용하면 각 파일을 이전
   상태로 되돌릴 수 있고, 프로젝트를 통째로 이전 상태로 되돌릴 수 있고, 시간에
   따라 수정 내용을 비교해 볼 수 있고, 누가 언제 만들어내 issue인지도 알 수
   있다. VCS를 사용하면 파일을 잃어 버리거나 잘못 고쳤을 때도 쉽게 복구할 수
   있다.

*** 로컬 버전 관리

    많은 사람들은 버전을 관리 하기 위해 디렉터리로 파일을 복사하는 방법을 쓴다.
    (똑똑한 사람이면 디렉터리 이름에 시간을 넣을 거다.) 하지만 작업하던
    디렉터리를 지워버리거나, 실수로 파일을 잘못 고칠 수도 있고, 잘못 복사할 수도
    있다.

    이런 이유로 프로그래머들은 오래전에 로컬 VCS 라는 걸 만들었다. 이 VCS는 아주
    간단한 데이터 베이스를 사용해서 파일의 변경 정보를 관리했다.

    많이 쓰는 VCS 도구 중에 *RCS* (Revision Control System)라고 있는데 오늘날
    까지도 많이 사용하고 있다. RCS는 기본적으로 *Patch Set* (파일에서 변경되는
    부분)을 관리한다. Mac OS X 에서도 개발도구를 설치하면 RCS가 같이 설치된다.

    이 Patch Set은 특별한 형식의 파일로 저장한다. 그리고 일련의 Patch Set을
    적용해서 모든 파일을 특정 시점으로 되돌릴 수 있다.
    
*** 중앙집중식 버전 관리 (CVCS)

    다른 사람들과 같이 작업해야 하는 경우, 생기는 문제를 해결하기 위해 *CVCS*
    (중앙집중식 VCS)가 개발됐다. CVS, Subversion, Perforce 같은 시스템은 파일을
    관리하는 서버가 별도로 있고 클라이언트가 중앙 서버에서 파일을 받아서
    사용(CheckOut)한다.

    CVCS 환경은 로컬 VCS에 비해 장점이 많다. 모두 누가 무엇을 하고 있는지 알 수
    있다. 관리자는 누가 무엇을 할 지 꼼꼼하게 관리할 수 있다. 모든 클라이언트의
    로컬 데이터베이스를 관리하는 것보다 VCS 하나를 관리하기가 훨씬 쉽다.

    그러나 이 CVCS 환경은 몇 가지 치명적인 결점이 있다. 가장 대표적인 것이
    중앙서버에 발생한 문제다.
    
*** 분산 버전 관리 시스템

    *DVCS* (분산 버전 관리 시스템)을 다룰 차례다. Git, Mecurial, Bazaar, Darcs
     같은 DVCS 에서의 클라이언트는 단순히 파일의 마지막 스냅샷을 Checkout하지
     않는다. 그냥 저장소를 전부 복제한다. 서버에 문제가 생기면 이 복제물로 다시
     작업을 시작할 수 있다. 클라이언트 중에서 아무거나 골라도 서버를 복원할 수
     있다. 모든 Checkout은 모든 데이터를 가진 진정한 백업이다.

     게다가 대부분의 DVCS 환경에서는 리모트 저장소가 존재한다. 사람들은 동시에
     다양한 그룹과 다양한 방법으로 협업할 수 있다. 계층 모델 같은 중앙 집중식
     시스템으로는 할 수 없는 워크플로를 다양하게 사용할 수 있다.
     
** 1.2 Git 의 역사

   Git은 창조적 파괴와 활활 타오르는 갈등 속에서 시작됐다.

   리눅스 커널은 굉장히 규모가 큰 오픈 소스 프로젝트다. 리눅스 커널의 삶
   대부분은 Patch와 단순 압축 파일로만 관리했다. 2002년에 드디어 리눅스 커널은
   BitKeeper라고 불리는 상용 DVCS를 사용하기 시작했다.

   2005년에 커뮤니티가 만드는 리눅스 커널과 이익을 추구하는 회사가 개발한
   BitKeeper의 관계가 틀어졌다. BitKeeper를 무료로 사용하지 못하게 된 것이다.

   이 사건은 리눅스 개발 커뮤니티 (특히 리눅스 창시자 리누스 토발즈)가 자체
   도구를 만드는 계기가 됐다. Git은 BitKeeper를 사용하면서 배운 교훈을 기초로
   아래와 같은 목표를 세웠다.

   + 빠른 속도
   + 단순한 구조
   + 비선형적인 개발(수천 개의 동시다발적인 브랜치)
   + 완벽한 분산
   + 리눅스 커널 같은 대형 프로젝트에도 유용할 것 (속도나 데이터 크기면에서)

   Git은 2005년에 탄생하고 나서 아직도 초기 목표를 그대로 유지하고 있다.
   그러면서도 사용하기 쉽게 진화하고 성숙했다. Git은 미친 듯이 빨라서 대형
   프로젝트에 사용하기도 좋다. Git은 동시다발적인 브랜치에도 끄떡없는 슈퍼
   울트라 브랜칭 시스템이다.
   
** 1.3 Git의 기초

   Git의 핵심은 뭘까? 이 질문은 Git을 이해하는 데 굉장히 중요하다.

   
*** 차이가 아니라 스냅샷
    
    Subversion과 Subversion 비슷한 VCS들과 Git 의 가장 큰 차이점은 데이터를
    다루는 방법에 있다.  큰 틀에서 봤을 때 VCS 대부분은 관리하는 정보가 파일들의
    목록이다. 각 파일의 변화를 시간순으로 관리하면서 파일들의 집합을 관리한다.

    Git은 이런 식으로 데이터를 저장하지도 취급하지도 않는다. 대신 Git 은
    데이터를 파일 시스템 스냅샷으로 취갑하고 크기가 아주 작다. Git은 커밋하거나
    프로젝트의 상태를 저장할 때마다 파일이 존재하는 그 순간을 중요하게 여긴다.
    파일이 달라지지 않았으면 Git은 성능을 위해서 파일을 새로 저장하지 않는다.
    단지 이전 상태의 파일에 대한 링크만 저장한다. Git은 데이터를 *스냅샷의
    스트림* 처럼 취급한다.

    
*** 거의 모든 명령을 로컬에서 실행

    거의 모든 명령이 로컬 파일과 데이터만 사용하기 때문에 네트워크에 있는 다른
    컴퓨터는 필요없다. 대부분의 명령어가 네트워크의 속도에 영향을 받는 CVCS에
    익숙하다면 Git이 매우 놀라울 것이다. Git의 이런 특징에서 나오는 미칠 듯한
    속도는 오직 Git느님만이 구사할 수 있는 전능이다. 프로젝트의 모든 히스토리가
    로컬 디스크에 있기 때문에 모든 명령을 순식간에 실행한다.

    예를 들어 Git은 프로젝트의 히스토리를 조회할 때 서버 없이 조회한다. 그냥
    로컬 데이터 베이스에서 히스토리를 읽어서 보여준다. 그래서 눈 깜짝할 사이에
    히스토리를 조회할 수 있다. 어떤 파일의 현재 버전과 한 달 전의 상태를
    비교해보고 싶을 때도 Git은 그냥 한 달 전의 파일과 지금의 파일을 로컬에서
    찾는다. 파일을 비교하기 위해 리모트에 있는 서버에 겁근하고 나서 예전 버전을
    가져올 필요가 없다.

    즉, 오프라인 상태이거나 VPN (Virtual Private Network)으로 연결할 수 없어도
    막힘없이 일할 수 있다. 비행기나 기차 등에서 네트워크에 접속하고 있지 않아도
    커밋할 수 있다는 얘기다. 다른 VCS에서는 불가능한 일이다. Perforce를 예로
    들자면 서버에 연결할 수 없을 때 할 수 있는 일이 별로 없다. Subversion이나
    CVS에서도 마찬가지다. 오프라인이기 때문에 데이터베이스에 접근할 수 없어서
    파일을 편집할 수는 있지만, 커밋할 수 없다. 매우 사소해 보이지만 실제로 이
    상황에 부닥쳐보면 느껴지는 차이가 매우 크다.
    
*** Git의 무결성

    Git은 데이터를 저장하기 전에 항상 체크섬을 구하고 그 체크섬으로 데이터를
    관리한다. 그래서 체크섬 없이는 어떠한 파일이나 디렉터리도 변경할 수 없다.
    체크섬은 Git에서 사용하는 가장 기본적인 데이터 단위이자 Git의 기본철학이다.
    Git없이는 체크섬을 다룰 수 없어서 파일의 상태도 알 수 없고 심지어 데이터를
    잃어 버릴 수도 없다.

    Git은 SHA-1 해시를 사용하여 테크섬을 만든다. 만든 체크섬은 40자 길이의
    16진수 문자열이다. 파일의 내용이나 디렉터리 구조를 이용하여 체크섬을 구한다
    SHA-1은 아래처럼 생겼다.

    #+BEGIN_CENTER
    ~24b9da566ee22987aa49b393f29485cd87d883229~
    #+END_CENTER

    Git은 모든 것을 해시로 식별하기 때문에 이런 값은 여기저기서 보인다. 실제로
    Git은 파일을 이름으로 저장하지 않고 해당 파일의 해시로 저장한다.

   
*** Git은 데이터를 추가할 뿐

    Git으로 무얼 하든 Git 데이터베이스에 데이터가 추가된다. 되돌리거나 데이터를
    삭제할 방법이 없다. 다른 VCS처럼 Git도 커밋하지 않으면 변경사항을 잃어버수
    있다.  하지만 일단 스냅샷을 커밋하고 나면 데이터를 잃어버리기 어렵다.

    
*** 세가지 상태

    이 부분은 Git을 공부하기 위해 반드시 짚고 넘어가야 할 부분이다. Git은 파일을
    *Committed*, *Modified*, *Staged* 이렇게 세 가지 상태로 관리한다.

    + *Committed*
      데이터가 로컬 데이터베이스에 안전하게 저장됐다는 것을 뜻한다.

    + *Modified*
      수정한 파일을 아직 로컬 데이터베이스에 커밋하지 않은 것을 말한다.

    + *Staged*
      현재 수정한 파일을 곧 커밋할 것이라고 표시한 상태를 뜻한다.

    이 세가지 상태는 Git 프로젝트의 세 가지 단계와 연결돼 있다. Git 디렉터리,
    워킹 디렉터리, Staging Area 이렇게 세가지 단계를 이해해야 한다.

    

   
