* /dev/random

** 1. 소개

    리눅스에서 제공하는 문자장치(character devices)를 이용한 랜덤 값을 얻어 내는 방법.

** 2. RANDOM 값 만들기

*** 2-1. 왜 RANDOM 값을?

    random의 뜻이 '임의의', '일정치 않는'의 뜻이란걸 누구든지 알고 있을 것이다. 가장 간단한 랜덤 값의 예는 주사위가 던져질 경우 나오는 눈의 수가 될것이며, "임의의" 값이 나오게 될 것이다. 

    이 임의의 값은 일상에서 자주 사용되며, 특히 보안을 필요로 하는 곳에서 더욱 중요하게 쓰인다. 카드에서 현금 서비스 등을 서비스 받기 위해사용하는 4자리 숫자의 조합등 '임의의' 값이 사용된다. 흔히 이런 숫자 조합을 만들 때, 가장 문제 되는게 "임의의" 값을 사용하지 않고 숫자 조합을 만든다는 것이다. 자기 생일이라든지, 아는 사람의 전화번호 등이 대표적인 예로, 이런 값들은 "임의의" 값이 아니다. 임의의 값이 아니라는 것은 유추가 가능함을 뜻하며, 유추가 가능하다는 것은 그만큼 헛점이 많아 질수 있다는 뜻이다. 

    컴퓨팅 환경에서도 이런 "임의의" 값을 선택할 수 있어야 한다. 선택된 임의의 값은 여러 용도로 쓰일텐데, 대표적으로 사용할 수 있는게 사용자 확인을 위한 "password" 와 SSL 과 같은 라이브러리 등에서 암호화 및 복호화를 위한 key 값등의 제작일 것이다. 

    이런 임의의 값들은 최대한 "임의의" 값으로서, 가능한 유추될 수 없는 값이 되어야 한다. 만약 우리가 "임의의" 값을 얻기 위한 어떤 함수를 만들었고, 이 함수를 통해 1-9999 사이의 임의의 값을 얻어내려고 하는데, 함수를 사용했더니 5000 - 6000 사이의 값이 다른 값보다 특별히 많 이나온다면, 이 함수는 믿을 수 없는 "결함이 있는" 함수가 될 것이며, 이 함수를 사용하는 많은 프로그램은 보안 결함을 가지게 된다. 이상적으로 각각의 값이 선택될 확률은 모두 동일(1/(값의 범위))해야 할것이다. 다른 말로 표준편차가 0.

*** 2-2. 표준 C random 함수 
    표준 C 에서는 랜덤 값의 계산을 위해 random () 와 srandom() 두개의 함수를 제공한다.
    
    #include <stdlib.h>
    
    long random (void);
    void srandom (unsigned int seed);

    srandom 함수는 random seed 값을 만들기 위해서 사용되며, random 은 만들어진 random seed 값을 이용해서 일련의 랜덤 값을 발생시킨다. 이말은 random 함수를 이용해서 발생되는 랜덤값은 srandom 에 의존적임을 뜻하며, 실제로 같은 random seed 를 이용해서 random 함수를 돌릴 경우 언제나 동일한 일련의 랜덤 값을 얻게 된다.

   srandom 에서의 random seed 는 argument로 주어지는 seed에 의해서 만들어진다.

   random 함수가 srandom 에서 만들어 내는 random seed 에 의해서 랜덤값을 만들어 낸다는 것은 그리 좋지 않은 아이디어라고 생각한다. 왜냐하면 seed 에 임의의 ini 값을 할당한다는 것이 생각처럼 쉬운게 아니기 때문이며 ( 보통은 컴퓨터의 시간값을 사용한다.), 이런 값은 유추될 수 있기 때문이다. 기본적으로 동일한 seed 값을 이용할 경우 동일한 일련의 랜덤 값을 얻을 수 있기 때문이다.

   또한 random 으로 만들어지는 랜덤값의 범위는 16 * ((2**31) - 1) 이다. 언뜻 보면 큰 숫자인 것 같다. 그러나 최근 SSL 등에서 key 의 크기가 128bit 인 것을 감안하면 너무 작은 범위의 랜덤 값만을 얻어 올 수 있어서, 현재 컴퓨팅 환경이 요구하는 수준에 크게 미달되고 있다.

   즉, 그리 복잡하거나 중요하지 않은 어플리케이션에서 랜덤 값을 만들기 위해서는 간단하게 사용가능하지만, 그렇지 않은 실제 서비스 환경에서는 사용하기 부족한 점이 있다.

**** 2-2-1. 성능 테스트
     random seed 를 제외하고 생각한다면, 랜덤 값은 정말 랜덤하게 나와야 한다. 예를 들어 1 - 100 까지의 범위에서 랜덤 값을 추출하고자 했을 때, 이것을 1000000 번 돌리면 1 - 100 사이의 값이 거의 비슷한 횟수로 선택되어져야 할 것이다. 약간 더 많이 선택되거나 그렇지 않은 랜덤 값이 있겠지만 대중 1000 정도에서 선택되어져야 할 것이며, 이 오차 폭이 작을 수록 성능이 좋은 랜덤 함수라고 할 수 있다.

     보통 이러한 통계수치에서 각각의 관측값이 평균에서 떨어진 정보를 가지고 얼마나 바람직하게 분포되어 있는지를 판단하게 되는데, 이를 표준편차라고 한다. 여기에서는 random 함수의 성능을 알아보기 위해서 표준편차를 구하고 이를 그래프로 확인해보도록 하겠다.

     이러한 표준편차를 구하기 위해서 간단한 테스트용 코드를 만들것이다. 이 코드는 srandom 을 이용해서 random seed 를 만들고, 이 random seed 를 통해서 random 을 100000번 돌리게 될것이다. 랜덤값의 범위는 1에서 100 사이가 될것이며, 각 관측값이 몇번씩 출력되는지를 확인하고, 이것을 이용해서 표준편차를 구하고, 그래프를 만들것이다. 참고로 표준편차를 구하는 일반적인 공식은 다음과 같다.
     ; 표준편차 공식

     다음은 테스트를 위한 코드이다.
     
     예제 : random_test.c
            =#include <stdlib.h>=
            
            =#include <string.h>=
            
            =#include <stdio.h>=
            
            =#include <math.h>= 

               =struct mdata=
               
               ={=
               
                  =int count;=
                  
                =};=

               int main()
               {
                 int i = 0;
                 struct mdata mydata[101];
                 int sum = 0;
                 int avg = 0;
                 int dosu = 0;
                 int dosu_p = 0;
                 memset((void *)&mydata, 0x00, sizeof(struct mdata)*101);
                 // srandom(100);

                 // 100000번 동안 0-99 사이의 랜덤값을 얻어온다.
                 while( i < 100000)
                 {
                    mydata[random()%100].count++;
                    i++;
                 }
                 
                 i = 0;

                 //카운팅된 랜덤 값을 이용해서
                 //평균, 합, 표준편차를 구해낸다.
                 while (i < 100)
                 {
                    sum += mydata[i].count;
                    printf("%d %d\n", i, mydata[i].count);
                    i++;
                  }
                  avg = sum/100;
                  printf("평균 : %d\n", avg);
                  printf("합   : %d\n", sum);
                  sum = 0;
                  i = 0;
                  while (i < 100)
                  {
                     sum + = (mydata[i].count - avg)*(mydata[i].count - avg);
                     i++;
                   }
                   // sqrt(sum/100) 을 하면 표준편차가
                   
                   // 나온다.
                   printf("%d\n", sum/100);
                 }
     
         위의 실행결과를 보면 표준편차는 대략 36 정도가 나온다. 이말은 평균값인 1000 에서 대략 36정도의 범위내에 모든 관측값이 위치함을 뜻한다. 괜찮은 성능을 보여준다는걸 알수 있다. 아래는 실행결과이다.
         96 1012
         97 992
         98 970
         99 1008
         평균 : 1000
         합   : 100000
         1303

         마지막 출력값인 1303 에 sqrt 연산을 해주면 표준편차를 구할수 있다.

*** 2-3. /dev/random 의 이용.
    Unix 에서는 좀더 범용적으로 사용할 수 있는 방법을 제공한다. '/dev/random' 이라는 문자장치를 통한 랜덤값 가져오기가 그 방법이다.

    이 문자장치는 커널에서 제공하는데, int형의 값을 이용해서 random seed 를 생성해내는 random 함수와는 달리 다른 장치 드라이버와 엔트로피 풀안의 다른 소스들로부터 노이즈를 모으고 이런 노이즈와 장치드라이버에 걸리는 인터럽트시간 간격등을 이용해서 난수를 만든다.

    간단히 말해서 키보드, 마우스, 디스크 혹은 내부적으로 발생되는 다른 인터럽트 등을 이용해서 난수를 발생시킨다고 보면 된다. 이들 인터럽트 값등은 예측하기가 매우 힘들기 때문에 근본적으로 random 함수를 이용하는 것보다 매우 안전하게 랜덤값을 만들 수 있다. 또한 난수의 범위를 매우 크게 잡을 수 있기 때문에, 128bit 크기를 사용하는 지금의 컴퓨팅 환경에 쓸모가 있게 된다.

    실제 openssl 과 같은 라이브러리 등은 암호화된 key 를 만들기 위해 '/dev/random' 를 쓴다. 다음의 128bit 크기의 난수를 만드는 짧은 본보기(예제) 프로그램이다.

    ;; dev_mem.c
    #include <unistd.h>
    #include <fcntl.h>
    #include <sys/stat.h>
    #include <sys/types.h>
    #include <stdlib.h>
    #include <stdio.h>
    #include <string.h>

    int main()
    {
        int i, fd;
        char key[16];
        if ((fd = open("/dev/random", O_RDONLY)) == -1)
        {
            perror("open error");
            exit(1);
         }


         if ((read(fd, key, 16)) == -1)
         {
             perror("read error");
             exit(1);
          }
          for (i = 0; i < 16; i++)
          {
              printf("%c", key[i]);
           }
       }

       위의 코드는 16 * 8(128)bit 크기를 가지는 랜덤값을 만들어낸다. 위프로그램을 실행시킨 결과값을 확인하기 좋게 만들기 위해서 mimecode 를 통해서 아래와 같이 출력해보았다.

                   [root@localhost c_source]# ./dev_mem | mimencode(mmencode)
                   6qK3AlTHc0nUUETnoL5LRA==
			mimencode(mmencode) 는 입력값을 base64 인코딩해서 그 결과를 출력하며, 보통 MIME 메시지를 첨부하기 위한 목적으로 사용되는 어플리케이션이다.

        코드는 매우 간단하며, 실행시마다 서로 다른 랜덤값이 출력되는걸 확인할수 있을것이다. 또한 랜덤값의 크기 제한역시 매우 자유롭다. 위의 key 배열의 크기를 32 로 한다면 간단하게 256bit 크기를 가지는 함수를 생성할수 있다.

        
**** 2-3-1. /dev/random 의 문제점

     /dev/random을 사용하는데 있어서 사소한(때에 따라서는 심각한) 문제가 하나 있는데, 장치의 노이즈를 수집해서 앤트로피 풀에 저장하고 이 값을 이용해서 랜덤값을 만들어 낸다는 특징 때문에 장치에 노이즈가 없을 때는 앤트로피 풀이 비어 버리고, 때문에 매우 오랜 시간동안 랜덤값이 발생하지 않을 수 있다는 점이다.

     다음의 코드를 테스트 해보기 바란다.

     =#include <time.h>=
     ~#include <stdio.h>~
     =#include <sys/types.h>=
     #include <unistd.h>
     #include <fcntl.h>

     #define MAX_RND_SIZE 32

     int random_init()
     {
         int fd;
         fd = open("/dev/random", O_RDONLY);
         return fd;
      }

     int random_get(int fd, void *buf, size_t size)
     {
          int i = 0;
          int n = 0;
          // 주석 1.

          while( n < size)
          {
                n += read(fd, buf, size - n);
           }

          return n;
      }

      int random_clear(int fd)
      {
          close(fd);
       }

      int main()
      {
          int fd;
          int n;
          unsigned int value;

          fd = random_init();
          sleep(5);
          while(1)
          {
               n = random_get(fd, (void *)&value, 4);
               printf("%d %lu\n", n, value);
           }
       random_clear(fd);

       }

       당신의 시스템이 조용한 상태라고 가정한다면 처음 몇 개는 발생하지만 그 후에는 띄엄띄엄 발생 하는 것을 확인할 수 있을 것이다. 자 이제 키보드를 눌러 보거나. 마우스를 움직여 보거나 복사와 같은 파일 관련 작업을 해보기 바란다. 아마 랜덤값이 빠르게 발생하는 걸 확인 할 수 있을 것이다.

       이러한 /dev/random의 특징 때문에 연속해서 랜덤한 값을 얻고자 할 때 문제가 발생할 수 있으니 이럴 경우 사용에 주의해야 한다.(물론 그리 흔한 경우가 아니긴 하지만)

       만약 읽어 들이려는 크기만큼의 노이즈가 앤트로피 풀에 있지 않을 경우 요청한 크기보다 더 적은 값을 읽어 올 수도 있으므로 짧은 시간에 여러개의 랜덤값을 생성해야 할 경우 사이즈를 계산해줘야 할 필요성이 있다.

       짧은 시간에 여러개의 랜덤값 생성은 인증값과 같은 중요한 부분에 사용된다고 보기는 힘들다. 이런 경우에는 그냥 random()을 이용하도록 하자.

** 결론

   이상간단하게 랜덤값을 얻어오는 2가지 일반적인 방법에 대해서 알아보았다. /dev/random 의 경우 나중에 다루게될 ssl 프로그래밍에서도 쓰임으로 알아 놓으면 언젠가 유용하게 써먹을수 있을것이다.
